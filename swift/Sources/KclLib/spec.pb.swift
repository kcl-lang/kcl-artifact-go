// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: spec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright The KCL Authors. All rights reserved.
//
// This file defines the request parameters and return structure of the KCL RPC server.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Message representing an external package for KCL.
/// kcl main.k -E pkg_name=pkg_path
public struct Com_Kcl_Api_ExternalPkg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the package.
  public var pkgName: String = String()

  /// Path of the package.
  public var pkgPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a key-value argument for KCL.
/// kcl main.k -D name=value
public struct Com_Kcl_Api_Argument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the argument.
  public var name: String = String()

  /// Value of the argument.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing an error.
public struct Com_Kcl_Api_Error: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Level of the error (e.g., "Error", "Warning").
  public var level: String = String()

  /// Error code. (e.g., "E1001")
  public var code: String = String()

  /// List of error messages.
  public var messages: [Com_Kcl_Api_Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a detailed error message with a position.
public struct Com_Kcl_Api_Message: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The error message text.
  public var msg: String = String()

  /// The position in the source code where the error occurred.
  public var pos: Com_Kcl_Api_Position {
    get {return _pos ?? Com_Kcl_Api_Position()}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  public var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  public mutating func clearPos() {self._pos = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pos: Com_Kcl_Api_Position? = nil
}

/// Message for ping request arguments.
public struct Com_Kcl_Api_Ping_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value to be sent in the ping request.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for ping response.
public struct Com_Kcl_Api_Ping_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value received in the ping response.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for version request arguments. Empty message.
public struct Com_Kcl_Api_GetVersion_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for version response.
public struct Com_Kcl_Api_GetVersion_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KCL version.
  public var version: String = String()

  /// Checksum of the KCL version.
  public var checksum: String = String()

  /// Git Git SHA of the KCL code repo.
  public var gitSha: String = String()

  /// Detailed version information as a string.
  public var versionInfo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for list method request arguments. Empty message.
public struct Com_Kcl_Api_ListMethod_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for list method response.
public struct Com_Kcl_Api_ListMethod_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of available method names.
  public var methodNameList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for parse file request arguments.
public struct Com_Kcl_Api_ParseFile_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the file to be parsed.
  public var path: String = String()

  /// Source code to be parsed.
  public var source: String = String()

  /// External packages path.
  public var externalPkgs: [Com_Kcl_Api_ExternalPkg] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for parse file response.
public struct Com_Kcl_Api_ParseFile_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Abstract Syntax Tree (AST) in JSON format.
  public var astJson: String = String()

  /// File dependency paths.
  public var deps: [String] = []

  /// List of parse errors.
  public var errors: [Com_Kcl_Api_Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for parse program request arguments.
public struct Com_Kcl_Api_ParseProgram_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Paths of the program files to be parsed.
  public var paths: [String] = []

  /// Source codes to be parsed.
  public var sources: [String] = []

  /// External packages path.
  public var externalPkgs: [Com_Kcl_Api_ExternalPkg] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for parse program response.
public struct Com_Kcl_Api_ParseProgram_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Abstract Syntax Tree (AST) in JSON format.
  public var astJson: String = String()

  /// Returns the files in the order they should be compiled.
  public var paths: [String] = []

  /// List of parse errors.
  public var errors: [Com_Kcl_Api_Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for load package request arguments.
public struct Com_Kcl_Api_LoadPackage_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arguments for parsing the program.
  public var parseArgs: Com_Kcl_Api_ParseProgram_Args {
    get {return _parseArgs ?? Com_Kcl_Api_ParseProgram_Args()}
    set {_parseArgs = newValue}
  }
  /// Returns true if `parseArgs` has been explicitly set.
  public var hasParseArgs: Bool {return self._parseArgs != nil}
  /// Clears the value of `parseArgs`. Subsequent reads from it will return its default value.
  public mutating func clearParseArgs() {self._parseArgs = nil}

  /// Flag indicating whether to resolve AST.
  public var resolveAst: Bool = false

  /// Flag indicating whether to load built-in modules.
  public var loadBuiltin: Bool = false

  /// Flag indicating whether to include AST index.
  public var withAstIndex: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parseArgs: Com_Kcl_Api_ParseProgram_Args? = nil
}

/// Message for load package response.
public struct Com_Kcl_Api_LoadPackage_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Program Abstract Syntax Tree (AST) in JSON format.
  public var program: String = String()

  /// Returns the files in the order they should be compiled.
  public var paths: [String] = []

  /// List of parse errors.
  public var parseErrors: [Com_Kcl_Api_Error] = []

  /// List of type errors.
  public var typeErrors: [Com_Kcl_Api_Error] = []

  /// Map of scopes with scope index as key.
  public var scopes: Dictionary<String,Com_Kcl_Api_Scope> = [:]

  /// Map of symbols with symbol index as key.
  public var symbols: Dictionary<String,Com_Kcl_Api_Symbol> = [:]

  /// Map of node-symbol associations with AST index UUID as key.
  public var nodeSymbolMap: Dictionary<String,Com_Kcl_Api_SymbolIndex> = [:]

  /// Map of symbol-node associations with symbol index as key.
  public var symbolNodeMap: Dictionary<String,String> = [:]

  /// Map of fully qualified names with symbol index as key.
  public var fullyQualifiedNameMap: Dictionary<String,Com_Kcl_Api_SymbolIndex> = [:]

  /// Map of package scope with package path as key.
  public var pkgScopeMap: Dictionary<String,Com_Kcl_Api_ScopeIndex> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for list options response.
public struct Com_Kcl_Api_ListOptions_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of available options.
  public var options: [Com_Kcl_Api_OptionHelp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a help option.
public struct Com_Kcl_Api_OptionHelp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the option.
  public var name: String = String()

  /// Type of the option.
  public var type: String = String()

  /// Flag indicating if the option is required.
  public var required: Bool = false

  /// Default value of the option.
  public var defaultValue: String = String()

  /// Help text for the option.
  public var help: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a symbol in KCL.
public struct Com_Kcl_Api_Symbol: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the symbol.
  public var ty: Com_Kcl_Api_KclType {
    get {return _ty ?? Com_Kcl_Api_KclType()}
    set {_ty = newValue}
  }
  /// Returns true if `ty` has been explicitly set.
  public var hasTy: Bool {return self._ty != nil}
  /// Clears the value of `ty`. Subsequent reads from it will return its default value.
  public mutating func clearTy() {self._ty = nil}

  /// Name of the symbol.
  public var name: String = String()

  /// Owner of the symbol.
  public var owner: Com_Kcl_Api_SymbolIndex {
    get {return _owner ?? Com_Kcl_Api_SymbolIndex()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// Definition of the symbol.
  public var def: Com_Kcl_Api_SymbolIndex {
    get {return _def ?? Com_Kcl_Api_SymbolIndex()}
    set {_def = newValue}
  }
  /// Returns true if `def` has been explicitly set.
  public var hasDef: Bool {return self._def != nil}
  /// Clears the value of `def`. Subsequent reads from it will return its default value.
  public mutating func clearDef() {self._def = nil}

  /// Attributes of the symbol.
  public var attrs: [Com_Kcl_Api_SymbolIndex] = []

  /// Flag indicating if the symbol is global.
  public var isGlobal: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ty: Com_Kcl_Api_KclType? = nil
  fileprivate var _owner: Com_Kcl_Api_SymbolIndex? = nil
  fileprivate var _def: Com_Kcl_Api_SymbolIndex? = nil
}

/// Message representing a scope in KCL.
public struct Com_Kcl_Api_Scope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the scope.
  public var kind: String = String()

  /// Parent scope.
  public var parent: Com_Kcl_Api_ScopeIndex {
    get {return _parent ?? Com_Kcl_Api_ScopeIndex()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  public var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  public mutating func clearParent() {self._parent = nil}

  /// Owner of the scope.
  public var owner: Com_Kcl_Api_SymbolIndex {
    get {return _owner ?? Com_Kcl_Api_SymbolIndex()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// Children of the scope.
  public var children: [Com_Kcl_Api_ScopeIndex] = []

  /// Definitions in the scope.
  public var defs: [Com_Kcl_Api_SymbolIndex] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parent: Com_Kcl_Api_ScopeIndex? = nil
  fileprivate var _owner: Com_Kcl_Api_SymbolIndex? = nil
}

/// Message representing a symbol index.
public struct Com_Kcl_Api_SymbolIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index identifier.
  public var i: UInt64 = 0

  /// Global identifier.
  public var g: UInt64 = 0

  /// Type of the symbol or scope.
  public var kind: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a scope index.
public struct Com_Kcl_Api_ScopeIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index identifier.
  public var i: UInt64 = 0

  /// Global identifier.
  public var g: UInt64 = 0

  /// Type of the scope.
  public var kind: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for execute program request arguments.
public struct Com_Kcl_Api_ExecProgram_Args: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Working directory.
  public var workDir: String {
    get {return _storage._workDir}
    set {_uniqueStorage()._workDir = newValue}
  }

  /// List of KCL filenames.
  public var kFilenameList: [String] {
    get {return _storage._kFilenameList}
    set {_uniqueStorage()._kFilenameList = newValue}
  }

  /// List of KCL codes.
  public var kCodeList: [String] {
    get {return _storage._kCodeList}
    set {_uniqueStorage()._kCodeList = newValue}
  }

  /// Arguments for the program.
  public var args: [Com_Kcl_Api_Argument] {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  /// Override configurations.
  public var overrides: [String] {
    get {return _storage._overrides}
    set {_uniqueStorage()._overrides = newValue}
  }

  /// Flag to disable YAML result.
  public var disableYamlResult: Bool {
    get {return _storage._disableYamlResult}
    set {_uniqueStorage()._disableYamlResult = newValue}
  }

  /// Flag to print override AST.
  public var printOverrideAst: Bool {
    get {return _storage._printOverrideAst}
    set {_uniqueStorage()._printOverrideAst = newValue}
  }

  /// Flag for strict range check.
  public var strictRangeCheck: Bool {
    get {return _storage._strictRangeCheck}
    set {_uniqueStorage()._strictRangeCheck = newValue}
  }

  /// Flag to disable none values.
  public var disableNone: Bool {
    get {return _storage._disableNone}
    set {_uniqueStorage()._disableNone = newValue}
  }

  /// Verbose level.
  public var verbose: Int32 {
    get {return _storage._verbose}
    set {_uniqueStorage()._verbose = newValue}
  }

  /// Debug level.
  public var debug: Int32 {
    get {return _storage._debug}
    set {_uniqueStorage()._debug = newValue}
  }

  /// Flag to sort keys in YAML/JSON results.
  public var sortKeys: Bool {
    get {return _storage._sortKeys}
    set {_uniqueStorage()._sortKeys = newValue}
  }

  /// External packages path.
  public var externalPkgs: [Com_Kcl_Api_ExternalPkg] {
    get {return _storage._externalPkgs}
    set {_uniqueStorage()._externalPkgs = newValue}
  }

  /// Flag to include schema type path in results.
  public var includeSchemaTypePath: Bool {
    get {return _storage._includeSchemaTypePath}
    set {_uniqueStorage()._includeSchemaTypePath = newValue}
  }

  /// Flag to compile only without execution.
  public var compileOnly: Bool {
    get {return _storage._compileOnly}
    set {_uniqueStorage()._compileOnly = newValue}
  }

  /// Flag to show hidden attributes.
  public var showHidden: Bool {
    get {return _storage._showHidden}
    set {_uniqueStorage()._showHidden = newValue}
  }

  /// Path selectors for results.
  public var pathSelector: [String] {
    get {return _storage._pathSelector}
    set {_uniqueStorage()._pathSelector = newValue}
  }

  /// Flag for fast evaluation.
  public var fastEval: Bool {
    get {return _storage._fastEval}
    set {_uniqueStorage()._fastEval = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Message for execute program response.
public struct Com_Kcl_Api_ExecProgram_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result in JSON format.
  public var jsonResult: String = String()

  /// Result in YAML format.
  public var yamlResult: String = String()

  /// Log message from execution.
  public var logMessage: String = String()

  /// Error message from execution.
  public var errMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for build program request arguments.
public struct Com_Kcl_Api_BuildProgram_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arguments for executing the program.
  public var execArgs: Com_Kcl_Api_ExecProgram_Args {
    get {return _execArgs ?? Com_Kcl_Api_ExecProgram_Args()}
    set {_execArgs = newValue}
  }
  /// Returns true if `execArgs` has been explicitly set.
  public var hasExecArgs: Bool {return self._execArgs != nil}
  /// Clears the value of `execArgs`. Subsequent reads from it will return its default value.
  public mutating func clearExecArgs() {self._execArgs = nil}

  /// Output path.
  public var output: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _execArgs: Com_Kcl_Api_ExecProgram_Args? = nil
}

/// Message for build program response.
public struct Com_Kcl_Api_BuildProgram_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the built program.
  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for execute artifact request arguments.
public struct Com_Kcl_Api_ExecArtifact_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the artifact.
  public var path: String = String()

  /// Arguments for executing the program.
  public var execArgs: Com_Kcl_Api_ExecProgram_Args {
    get {return _execArgs ?? Com_Kcl_Api_ExecProgram_Args()}
    set {_execArgs = newValue}
  }
  /// Returns true if `execArgs` has been explicitly set.
  public var hasExecArgs: Bool {return self._execArgs != nil}
  /// Clears the value of `execArgs`. Subsequent reads from it will return its default value.
  public mutating func clearExecArgs() {self._execArgs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _execArgs: Com_Kcl_Api_ExecProgram_Args? = nil
}

/// Message for format code request arguments.
public struct Com_Kcl_Api_FormatCode_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source code to be formatted.
  public var source: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for format code response.
public struct Com_Kcl_Api_FormatCode_Result: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Formatted code as bytes.
  public var formatted: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for format file path request arguments.
public struct Com_Kcl_Api_FormatPath_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the file to format.
  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for format file path response.
public struct Com_Kcl_Api_FormatPath_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of changed file paths.
  public var changedPaths: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for lint file path request arguments.
public struct Com_Kcl_Api_LintPath_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Paths of the files to lint.
  public var paths: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for lint file path response.
public struct Com_Kcl_Api_LintPath_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of lint results.
  public var results: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for override file request arguments.
public struct Com_Kcl_Api_OverrideFile_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path of the file to override.
  public var file: String = String()

  /// List of override specifications.
  public var specs: [String] = []

  /// List of import paths.
  public var importPaths: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for override file response.
public struct Com_Kcl_Api_OverrideFile_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result of the override operation.
  public var result: Bool = false

  /// List of parse errors encountered.
  public var parseErrors: [Com_Kcl_Api_Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for list variables options.
public struct Com_Kcl_Api_ListVariables_Options: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Flag to merge program configuration.
  public var mergeProgram: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a list of variables.
public struct Com_Kcl_Api_VariableList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of variables.
  public var variables: [Com_Kcl_Api_Variable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for list variables request arguments.
public struct Com_Kcl_Api_ListVariables_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Files to be processed.
  public var files: [String] = []

  /// Specifications for variables.
  public var specs: [String] = []

  /// Options for listing variables.
  public var options: Com_Kcl_Api_ListVariables_Options {
    get {return _options ?? Com_Kcl_Api_ListVariables_Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Com_Kcl_Api_ListVariables_Options? = nil
}

/// Message for list variables response.
public struct Com_Kcl_Api_ListVariables_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of variable lists by file.
  public var variables: Dictionary<String,Com_Kcl_Api_VariableList> = [:]

  /// List of unsupported codes.
  public var unsupportedCodes: [String] = []

  /// List of parse errors encountered.
  public var parseErrors: [Com_Kcl_Api_Error] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a variable.
public struct Com_Kcl_Api_Variable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value of the variable.
  public var value: String = String()

  /// Type name of the variable.
  public var typeName: String = String()

  /// Operation symbol associated with the variable.
  public var opSym: String = String()

  /// List items if the variable is a list.
  public var listItems: [Com_Kcl_Api_Variable] = []

  /// Dictionary entries if the variable is a dictionary.
  public var dictEntries: [Com_Kcl_Api_MapEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a map entry.
public struct Com_Kcl_Api_MapEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key of the map entry.
  public var key: String = String()

  /// Value of the map entry.
  public var value: Com_Kcl_Api_Variable {
    get {return _value ?? Com_Kcl_Api_Variable()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Com_Kcl_Api_Variable? = nil
}

/// Message for get schema type mapping request arguments.
public struct Com_Kcl_Api_GetSchemaTypeMapping_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arguments for executing the program.
  public var execArgs: Com_Kcl_Api_ExecProgram_Args {
    get {return _execArgs ?? Com_Kcl_Api_ExecProgram_Args()}
    set {_execArgs = newValue}
  }
  /// Returns true if `execArgs` has been explicitly set.
  public var hasExecArgs: Bool {return self._execArgs != nil}
  /// Clears the value of `execArgs`. Subsequent reads from it will return its default value.
  public mutating func clearExecArgs() {self._execArgs = nil}

  /// Name of the schema.
  public var schemaName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _execArgs: Com_Kcl_Api_ExecProgram_Args? = nil
}

/// Message for get schema type mapping response.
public struct Com_Kcl_Api_GetSchemaTypeMapping_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of schema type mappings.
  public var schemaTypeMapping: Dictionary<String,Com_Kcl_Api_KclType> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for get schema type mapping response.
public struct Com_Kcl_Api_GetSchemaTypeMappingUnderPath_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of pkg and schema types mappings.
  public var schemaTypeMapping: Dictionary<String,Com_Kcl_Api_SchemaTypes> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Com_Kcl_Api_SchemaTypes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of schema type mappings.
  public var schemaType: [Com_Kcl_Api_KclType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for validate code request arguments.
public struct Com_Kcl_Api_ValidateCode_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the data file.
  public var datafile: String = String()

  /// Data content.
  public var data: String = String()

  /// Path to the code file.
  public var file: String = String()

  /// Source code content.
  public var code: String = String()

  /// Name of the schema.
  public var schema: String = String()

  /// Name of the attribute.
  public var attributeName: String = String()

  /// Format of the validation (e.g., "json", "yaml").
  public var format: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for validate code response.
public struct Com_Kcl_Api_ValidateCode_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Flag indicating if validation was successful.
  public var success: Bool = false

  /// Error message from validation.
  public var errMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a position in the source code.
public struct Com_Kcl_Api_Position: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Line number.
  public var line: Int64 = 0

  /// Column number.
  public var column: Int64 = 0

  /// Filename the position refers to.
  public var filename: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for list dependency files request arguments.
public struct Com_Kcl_Api_ListDepFiles_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Working directory.
  public var workDir: String = String()

  /// Flag to use absolute paths.
  public var useAbsPath: Bool = false

  /// Flag to include all files.
  public var includeAll: Bool = false

  /// Flag to use fast parser.
  public var useFastParser: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for list dependency files response.
public struct Com_Kcl_Api_ListDepFiles_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Root package path.
  public var pkgroot: String = String()

  /// Package path.
  public var pkgpath: String = String()

  /// List of file paths in the package.
  public var files: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for load settings files request arguments.
public struct Com_Kcl_Api_LoadSettingsFiles_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Working directory.
  public var workDir: String = String()

  /// Setting files to load.
  public var files: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for load settings files response.
public struct Com_Kcl_Api_LoadSettingsFiles_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KCL CLI configuration.
  public var kclCliConfigs: Com_Kcl_Api_CliConfig {
    get {return _kclCliConfigs ?? Com_Kcl_Api_CliConfig()}
    set {_kclCliConfigs = newValue}
  }
  /// Returns true if `kclCliConfigs` has been explicitly set.
  public var hasKclCliConfigs: Bool {return self._kclCliConfigs != nil}
  /// Clears the value of `kclCliConfigs`. Subsequent reads from it will return its default value.
  public mutating func clearKclCliConfigs() {self._kclCliConfigs = nil}

  /// List of KCL options as key-value pairs.
  public var kclOptions: [Com_Kcl_Api_KeyValuePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _kclCliConfigs: Com_Kcl_Api_CliConfig? = nil
}

/// Message representing KCL CLI configuration.
public struct Com_Kcl_Api_CliConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of files.
  public var files: [String] = []

  /// Output path.
  public var output: String = String()

  /// List of overrides.
  public var overrides: [String] = []

  /// Path selectors.
  public var pathSelector: [String] = []

  /// Flag for strict range check.
  public var strictRangeCheck: Bool = false

  /// Flag to disable none values.
  public var disableNone: Bool = false

  /// Verbose level.
  public var verbose: Int64 = 0

  /// Debug flag.
  public var debug: Bool = false

  /// Flag to sort keys in YAML/JSON results.
  public var sortKeys: Bool = false

  /// Flag to show hidden attributes.
  public var showHidden: Bool = false

  /// Flag to include schema type path in results.
  public var includeSchemaTypePath: Bool = false

  /// Flag for fast evaluation.
  public var fastEval: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a key-value pair.
public struct Com_Kcl_Api_KeyValuePair: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key of the pair.
  public var key: String = String()

  /// Value of the pair.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for rename request arguments.
public struct Com_Kcl_Api_Rename_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// File path to the package root.
  public var packageRoot: String = String()

  /// Path to the target symbol to be renamed.
  public var symbolPath: String = String()

  /// Paths to the source code files.
  public var filePaths: [String] = []

  /// New name of the symbol.
  public var newName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for rename response.
public struct Com_Kcl_Api_Rename_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of file paths that got changed.
  public var changedFiles: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for rename code request arguments.
public struct Com_Kcl_Api_RenameCode_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// File path to the package root.
  public var packageRoot: String = String()

  /// Path to the target symbol to be renamed.
  public var symbolPath: String = String()

  /// Map of source code with filename as key and code as value.
  public var sourceCodes: Dictionary<String,String> = [:]

  /// New name of the symbol.
  public var newName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for rename code response.
public struct Com_Kcl_Api_RenameCode_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of changed code with filename as key and modified code as value.
  public var changedCodes: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for test request arguments.
public struct Com_Kcl_Api_Test_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Execution program arguments.
  public var execArgs: Com_Kcl_Api_ExecProgram_Args {
    get {return _execArgs ?? Com_Kcl_Api_ExecProgram_Args()}
    set {_execArgs = newValue}
  }
  /// Returns true if `execArgs` has been explicitly set.
  public var hasExecArgs: Bool {return self._execArgs != nil}
  /// Clears the value of `execArgs`. Subsequent reads from it will return its default value.
  public mutating func clearExecArgs() {self._execArgs = nil}

  /// List of KCL package paths to be tested.
  public var pkgList: [String] = []

  /// Regular expression for filtering tests to run.
  public var runRegexp: String = String()

  /// Flag to stop the test run on the first failure.
  public var failFast: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _execArgs: Com_Kcl_Api_ExecProgram_Args? = nil
}

/// Message for test response.
public struct Com_Kcl_Api_Test_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of test case information.
  public var info: [Com_Kcl_Api_TestCaseInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing information about a single test case.
public struct Com_Kcl_Api_TestCaseInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the test case.
  public var name: String = String()

  /// Error message if any.
  public var error: String = String()

  /// Duration of the test case in microseconds.
  public var duration: UInt64 = 0

  /// Log message from the test case.
  public var logMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for update dependencies request arguments.
public struct Com_Kcl_Api_UpdateDependencies_Args: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the manifest file.
  public var manifestPath: String = String()

  /// Flag to vendor dependencies locally.
  public var vendor: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message for update dependencies response.
public struct Com_Kcl_Api_UpdateDependencies_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of external packages updated.
  public var externalPkgs: [Com_Kcl_Api_ExternalPkg] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing a KCL type.
public struct Com_Kcl_Api_KclType: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type name (e.g., schema, dict, list, str, int, float, bool, any, union, number_multiplier).
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Union types if applicable.
  public var unionTypes: [Com_Kcl_Api_KclType] {
    get {return _storage._unionTypes}
    set {_uniqueStorage()._unionTypes = newValue}
  }

  /// Default value of the type.
  public var `default`: String {
    get {return _storage._default}
    set {_uniqueStorage()._default = newValue}
  }

  /// Name of the schema if applicable.
  public var schemaName: String {
    get {return _storage._schemaName}
    set {_uniqueStorage()._schemaName = newValue}
  }

  /// Documentation for the schema.
  public var schemaDoc: String {
    get {return _storage._schemaDoc}
    set {_uniqueStorage()._schemaDoc = newValue}
  }

  /// Properties of the schema as a map with property name as key.
  public var properties: Dictionary<String,Com_Kcl_Api_KclType> {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  /// List of required schema properties.
  public var required: [String] {
    get {return _storage._required}
    set {_uniqueStorage()._required = newValue}
  }

  /// Key type if the KclType is a dictionary.
  public var key: Com_Kcl_Api_KclType {
    get {return _storage._key ?? Com_Kcl_Api_KclType()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Item type if the KclType is a list or dictionary.
  public var item: Com_Kcl_Api_KclType {
    get {return _storage._item ?? Com_Kcl_Api_KclType()}
    set {_uniqueStorage()._item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return _storage._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {_uniqueStorage()._item = nil}

  /// Line number where the type is defined.
  public var line: Int32 {
    get {return _storage._line}
    set {_uniqueStorage()._line = newValue}
  }

  /// List of decorators for the schema.
  public var decorators: [Com_Kcl_Api_Decorator] {
    get {return _storage._decorators}
    set {_uniqueStorage()._decorators = newValue}
  }

  /// Absolute path of the file where the attribute is located.
  public var filename: String {
    get {return _storage._filename}
    set {_uniqueStorage()._filename = newValue}
  }

  /// Path of the package where the attribute is located.
  public var pkgPath: String {
    get {return _storage._pkgPath}
    set {_uniqueStorage()._pkgPath = newValue}
  }

  /// Documentation for the attribute.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Map of examples with example name as key.
  public var examples: Dictionary<String,Com_Kcl_Api_Example> {
    get {return _storage._examples}
    set {_uniqueStorage()._examples = newValue}
  }

  /// Base schema if applicable.
  public var baseSchema: Com_Kcl_Api_KclType {
    get {return _storage._baseSchema ?? Com_Kcl_Api_KclType()}
    set {_uniqueStorage()._baseSchema = newValue}
  }
  /// Returns true if `baseSchema` has been explicitly set.
  public var hasBaseSchema: Bool {return _storage._baseSchema != nil}
  /// Clears the value of `baseSchema`. Subsequent reads from it will return its default value.
  public mutating func clearBaseSchema() {_uniqueStorage()._baseSchema = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Message representing a decorator in KCL.
public struct Com_Kcl_Api_Decorator: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the decorator.
  public var name: String = String()

  /// Arguments for the decorator.
  public var arguments: [String] = []

  /// Keyword arguments for the decorator as a map with keyword name as key.
  public var keywords: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing an example in KCL.
public struct Com_Kcl_Api_Example: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Short description for the example.
  public var summary: String = String()

  /// Long description for the example.
  public var description_p: String = String()

  /// Embedded literal example.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.kcl.api"

extension Com_Kcl_Api_ExternalPkg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalPkg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pkg_name"),
    2: .standard(proto: "pkg_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pkgName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pkgPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pkgName.isEmpty {
      try visitor.visitSingularStringField(value: self.pkgName, fieldNumber: 1)
    }
    if !self.pkgPath.isEmpty {
      try visitor.visitSingularStringField(value: self.pkgPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ExternalPkg, rhs: Com_Kcl_Api_ExternalPkg) -> Bool {
    if lhs.pkgName != rhs.pkgName {return false}
    if lhs.pkgPath != rhs.pkgPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Argument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Argument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Argument, rhs: Com_Kcl_Api_Argument) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "code"),
    3: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.level) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.level.isEmpty {
      try visitor.visitSingularStringField(value: self.level, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Error, rhs: Com_Kcl_Api_Error) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.code != rhs.code {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "pos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    try { if let v = self._pos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Message, rhs: Com_Kcl_Api_Message) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs._pos != rhs._pos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Ping_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ping_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Ping_Args, rhs: Com_Kcl_Api_Ping_Args) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Ping_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ping_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Ping_Result, rhs: Com_Kcl_Api_Ping_Result) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_GetVersion_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVersion_Args"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_GetVersion_Args, rhs: Com_Kcl_Api_GetVersion_Args) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_GetVersion_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVersion_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "checksum"),
    3: .standard(proto: "git_sha"),
    4: .standard(proto: "version_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gitSha) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.versionInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 2)
    }
    if !self.gitSha.isEmpty {
      try visitor.visitSingularStringField(value: self.gitSha, fieldNumber: 3)
    }
    if !self.versionInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.versionInfo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_GetVersion_Result, rhs: Com_Kcl_Api_GetVersion_Result) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.gitSha != rhs.gitSha {return false}
    if lhs.versionInfo != rhs.versionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListMethod_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMethod_Args"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListMethod_Args, rhs: Com_Kcl_Api_ListMethod_Args) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListMethod_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMethod_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_name_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.methodNameList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methodNameList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.methodNameList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListMethod_Result, rhs: Com_Kcl_Api_ListMethod_Result) -> Bool {
    if lhs.methodNameList != rhs.methodNameList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ParseFile_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParseFile_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "source"),
    3: .standard(proto: "external_pkgs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.externalPkgs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 2)
    }
    if !self.externalPkgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalPkgs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ParseFile_Args, rhs: Com_Kcl_Api_ParseFile_Args) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.source != rhs.source {return false}
    if lhs.externalPkgs != rhs.externalPkgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ParseFile_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParseFile_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ast_json"),
    2: .same(proto: "deps"),
    3: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.astJson) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.deps) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.astJson.isEmpty {
      try visitor.visitSingularStringField(value: self.astJson, fieldNumber: 1)
    }
    if !self.deps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deps, fieldNumber: 2)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ParseFile_Result, rhs: Com_Kcl_Api_ParseFile_Result) -> Bool {
    if lhs.astJson != rhs.astJson {return false}
    if lhs.deps != rhs.deps {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ParseProgram_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParseProgram_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paths"),
    2: .same(proto: "sources"),
    3: .standard(proto: "external_pkgs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.sources) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.externalPkgs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 1)
    }
    if !self.sources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sources, fieldNumber: 2)
    }
    if !self.externalPkgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalPkgs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ParseProgram_Args, rhs: Com_Kcl_Api_ParseProgram_Args) -> Bool {
    if lhs.paths != rhs.paths {return false}
    if lhs.sources != rhs.sources {return false}
    if lhs.externalPkgs != rhs.externalPkgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ParseProgram_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParseProgram_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ast_json"),
    2: .same(proto: "paths"),
    3: .same(proto: "errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.astJson) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.astJson.isEmpty {
      try visitor.visitSingularStringField(value: self.astJson, fieldNumber: 1)
    }
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 2)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ParseProgram_Result, rhs: Com_Kcl_Api_ParseProgram_Result) -> Bool {
    if lhs.astJson != rhs.astJson {return false}
    if lhs.paths != rhs.paths {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_LoadPackage_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadPackage_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parse_args"),
    2: .standard(proto: "resolve_ast"),
    3: .standard(proto: "load_builtin"),
    4: .standard(proto: "with_ast_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parseArgs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.resolveAst) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.loadBuiltin) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.withAstIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parseArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.resolveAst != false {
      try visitor.visitSingularBoolField(value: self.resolveAst, fieldNumber: 2)
    }
    if self.loadBuiltin != false {
      try visitor.visitSingularBoolField(value: self.loadBuiltin, fieldNumber: 3)
    }
    if self.withAstIndex != false {
      try visitor.visitSingularBoolField(value: self.withAstIndex, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_LoadPackage_Args, rhs: Com_Kcl_Api_LoadPackage_Args) -> Bool {
    if lhs._parseArgs != rhs._parseArgs {return false}
    if lhs.resolveAst != rhs.resolveAst {return false}
    if lhs.loadBuiltin != rhs.loadBuiltin {return false}
    if lhs.withAstIndex != rhs.withAstIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_LoadPackage_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadPackage_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "program"),
    2: .same(proto: "paths"),
    3: .standard(proto: "parse_errors"),
    4: .standard(proto: "type_errors"),
    5: .same(proto: "scopes"),
    6: .same(proto: "symbols"),
    7: .standard(proto: "node_symbol_map"),
    8: .standard(proto: "symbol_node_map"),
    9: .standard(proto: "fully_qualified_name_map"),
    10: .standard(proto: "pkg_scope_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.program) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parseErrors) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.typeErrors) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_Scope>.self, value: &self.scopes) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_Symbol>.self, value: &self.symbols) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_SymbolIndex>.self, value: &self.nodeSymbolMap) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.symbolNodeMap) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_SymbolIndex>.self, value: &self.fullyQualifiedNameMap) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_ScopeIndex>.self, value: &self.pkgScopeMap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.program.isEmpty {
      try visitor.visitSingularStringField(value: self.program, fieldNumber: 1)
    }
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 2)
    }
    if !self.parseErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parseErrors, fieldNumber: 3)
    }
    if !self.typeErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.typeErrors, fieldNumber: 4)
    }
    if !self.scopes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_Scope>.self, value: self.scopes, fieldNumber: 5)
    }
    if !self.symbols.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_Symbol>.self, value: self.symbols, fieldNumber: 6)
    }
    if !self.nodeSymbolMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_SymbolIndex>.self, value: self.nodeSymbolMap, fieldNumber: 7)
    }
    if !self.symbolNodeMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.symbolNodeMap, fieldNumber: 8)
    }
    if !self.fullyQualifiedNameMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_SymbolIndex>.self, value: self.fullyQualifiedNameMap, fieldNumber: 9)
    }
    if !self.pkgScopeMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_ScopeIndex>.self, value: self.pkgScopeMap, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_LoadPackage_Result, rhs: Com_Kcl_Api_LoadPackage_Result) -> Bool {
    if lhs.program != rhs.program {return false}
    if lhs.paths != rhs.paths {return false}
    if lhs.parseErrors != rhs.parseErrors {return false}
    if lhs.typeErrors != rhs.typeErrors {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.symbols != rhs.symbols {return false}
    if lhs.nodeSymbolMap != rhs.nodeSymbolMap {return false}
    if lhs.symbolNodeMap != rhs.symbolNodeMap {return false}
    if lhs.fullyQualifiedNameMap != rhs.fullyQualifiedNameMap {return false}
    if lhs.pkgScopeMap != rhs.pkgScopeMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListOptions_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOptions_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListOptions_Result, rhs: Com_Kcl_Api_ListOptions_Result) -> Bool {
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_OptionHelp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptionHelp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "required"),
    4: .standard(proto: "default_value"),
    5: .same(proto: "help"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.help) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 3)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 4)
    }
    if !self.help.isEmpty {
      try visitor.visitSingularStringField(value: self.help, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_OptionHelp, rhs: Com_Kcl_Api_OptionHelp) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.required != rhs.required {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.help != rhs.help {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Symbol: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Symbol"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ty"),
    2: .same(proto: "name"),
    3: .same(proto: "owner"),
    4: .same(proto: "def"),
    5: .same(proto: "attrs"),
    6: .standard(proto: "is_global"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ty) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._def) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.attrs) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isGlobal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ty {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._def {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.attrs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attrs, fieldNumber: 5)
    }
    if self.isGlobal != false {
      try visitor.visitSingularBoolField(value: self.isGlobal, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Symbol, rhs: Com_Kcl_Api_Symbol) -> Bool {
    if lhs._ty != rhs._ty {return false}
    if lhs.name != rhs.name {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._def != rhs._def {return false}
    if lhs.attrs != rhs.attrs {return false}
    if lhs.isGlobal != rhs.isGlobal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Scope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Scope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "parent"),
    3: .same(proto: "owner"),
    4: .same(proto: "children"),
    5: .same(proto: "defs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parent) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.defs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 4)
    }
    if !self.defs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.defs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Scope, rhs: Com_Kcl_Api_Scope) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._parent != rhs._parent {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs.children != rhs.children {return false}
    if lhs.defs != rhs.defs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_SymbolIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymbolIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "i"),
    2: .same(proto: "g"),
    3: .same(proto: "kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.i) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.g) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.i != 0 {
      try visitor.visitSingularUInt64Field(value: self.i, fieldNumber: 1)
    }
    if self.g != 0 {
      try visitor.visitSingularUInt64Field(value: self.g, fieldNumber: 2)
    }
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_SymbolIndex, rhs: Com_Kcl_Api_SymbolIndex) -> Bool {
    if lhs.i != rhs.i {return false}
    if lhs.g != rhs.g {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ScopeIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopeIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "i"),
    2: .same(proto: "g"),
    3: .same(proto: "kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.i) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.g) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.i != 0 {
      try visitor.visitSingularUInt64Field(value: self.i, fieldNumber: 1)
    }
    if self.g != 0 {
      try visitor.visitSingularUInt64Field(value: self.g, fieldNumber: 2)
    }
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ScopeIndex, rhs: Com_Kcl_Api_ScopeIndex) -> Bool {
    if lhs.i != rhs.i {return false}
    if lhs.g != rhs.g {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ExecProgram_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecProgram_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "work_dir"),
    2: .standard(proto: "k_filename_list"),
    3: .standard(proto: "k_code_list"),
    4: .same(proto: "args"),
    5: .same(proto: "overrides"),
    6: .standard(proto: "disable_yaml_result"),
    7: .standard(proto: "print_override_ast"),
    8: .standard(proto: "strict_range_check"),
    9: .standard(proto: "disable_none"),
    10: .same(proto: "verbose"),
    11: .same(proto: "debug"),
    12: .standard(proto: "sort_keys"),
    13: .standard(proto: "external_pkgs"),
    14: .standard(proto: "include_schema_type_path"),
    15: .standard(proto: "compile_only"),
    16: .standard(proto: "show_hidden"),
    17: .standard(proto: "path_selector"),
    18: .standard(proto: "fast_eval"),
  ]

  fileprivate class _StorageClass {
    var _workDir: String = String()
    var _kFilenameList: [String] = []
    var _kCodeList: [String] = []
    var _args: [Com_Kcl_Api_Argument] = []
    var _overrides: [String] = []
    var _disableYamlResult: Bool = false
    var _printOverrideAst: Bool = false
    var _strictRangeCheck: Bool = false
    var _disableNone: Bool = false
    var _verbose: Int32 = 0
    var _debug: Int32 = 0
    var _sortKeys: Bool = false
    var _externalPkgs: [Com_Kcl_Api_ExternalPkg] = []
    var _includeSchemaTypePath: Bool = false
    var _compileOnly: Bool = false
    var _showHidden: Bool = false
    var _pathSelector: [String] = []
    var _fastEval: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _workDir = source._workDir
      _kFilenameList = source._kFilenameList
      _kCodeList = source._kCodeList
      _args = source._args
      _overrides = source._overrides
      _disableYamlResult = source._disableYamlResult
      _printOverrideAst = source._printOverrideAst
      _strictRangeCheck = source._strictRangeCheck
      _disableNone = source._disableNone
      _verbose = source._verbose
      _debug = source._debug
      _sortKeys = source._sortKeys
      _externalPkgs = source._externalPkgs
      _includeSchemaTypePath = source._includeSchemaTypePath
      _compileOnly = source._compileOnly
      _showHidden = source._showHidden
      _pathSelector = source._pathSelector
      _fastEval = source._fastEval
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workDir) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._kFilenameList) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._kCodeList) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._args) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._overrides) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._disableYamlResult) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._printOverrideAst) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._strictRangeCheck) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._disableNone) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._verbose) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._debug) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._sortKeys) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._externalPkgs) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._includeSchemaTypePath) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._compileOnly) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._showHidden) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._pathSelector) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._fastEval) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._workDir.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workDir, fieldNumber: 1)
      }
      if !_storage._kFilenameList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._kFilenameList, fieldNumber: 2)
      }
      if !_storage._kCodeList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._kCodeList, fieldNumber: 3)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._args, fieldNumber: 4)
      }
      if !_storage._overrides.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._overrides, fieldNumber: 5)
      }
      if _storage._disableYamlResult != false {
        try visitor.visitSingularBoolField(value: _storage._disableYamlResult, fieldNumber: 6)
      }
      if _storage._printOverrideAst != false {
        try visitor.visitSingularBoolField(value: _storage._printOverrideAst, fieldNumber: 7)
      }
      if _storage._strictRangeCheck != false {
        try visitor.visitSingularBoolField(value: _storage._strictRangeCheck, fieldNumber: 8)
      }
      if _storage._disableNone != false {
        try visitor.visitSingularBoolField(value: _storage._disableNone, fieldNumber: 9)
      }
      if _storage._verbose != 0 {
        try visitor.visitSingularInt32Field(value: _storage._verbose, fieldNumber: 10)
      }
      if _storage._debug != 0 {
        try visitor.visitSingularInt32Field(value: _storage._debug, fieldNumber: 11)
      }
      if _storage._sortKeys != false {
        try visitor.visitSingularBoolField(value: _storage._sortKeys, fieldNumber: 12)
      }
      if !_storage._externalPkgs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._externalPkgs, fieldNumber: 13)
      }
      if _storage._includeSchemaTypePath != false {
        try visitor.visitSingularBoolField(value: _storage._includeSchemaTypePath, fieldNumber: 14)
      }
      if _storage._compileOnly != false {
        try visitor.visitSingularBoolField(value: _storage._compileOnly, fieldNumber: 15)
      }
      if _storage._showHidden != false {
        try visitor.visitSingularBoolField(value: _storage._showHidden, fieldNumber: 16)
      }
      if !_storage._pathSelector.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._pathSelector, fieldNumber: 17)
      }
      if _storage._fastEval != false {
        try visitor.visitSingularBoolField(value: _storage._fastEval, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ExecProgram_Args, rhs: Com_Kcl_Api_ExecProgram_Args) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workDir != rhs_storage._workDir {return false}
        if _storage._kFilenameList != rhs_storage._kFilenameList {return false}
        if _storage._kCodeList != rhs_storage._kCodeList {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._overrides != rhs_storage._overrides {return false}
        if _storage._disableYamlResult != rhs_storage._disableYamlResult {return false}
        if _storage._printOverrideAst != rhs_storage._printOverrideAst {return false}
        if _storage._strictRangeCheck != rhs_storage._strictRangeCheck {return false}
        if _storage._disableNone != rhs_storage._disableNone {return false}
        if _storage._verbose != rhs_storage._verbose {return false}
        if _storage._debug != rhs_storage._debug {return false}
        if _storage._sortKeys != rhs_storage._sortKeys {return false}
        if _storage._externalPkgs != rhs_storage._externalPkgs {return false}
        if _storage._includeSchemaTypePath != rhs_storage._includeSchemaTypePath {return false}
        if _storage._compileOnly != rhs_storage._compileOnly {return false}
        if _storage._showHidden != rhs_storage._showHidden {return false}
        if _storage._pathSelector != rhs_storage._pathSelector {return false}
        if _storage._fastEval != rhs_storage._fastEval {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ExecProgram_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecProgram_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_result"),
    2: .standard(proto: "yaml_result"),
    3: .standard(proto: "log_message"),
    4: .standard(proto: "err_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jsonResult) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.yamlResult) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logMessage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jsonResult.isEmpty {
      try visitor.visitSingularStringField(value: self.jsonResult, fieldNumber: 1)
    }
    if !self.yamlResult.isEmpty {
      try visitor.visitSingularStringField(value: self.yamlResult, fieldNumber: 2)
    }
    if !self.logMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.logMessage, fieldNumber: 3)
    }
    if !self.errMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ExecProgram_Result, rhs: Com_Kcl_Api_ExecProgram_Result) -> Bool {
    if lhs.jsonResult != rhs.jsonResult {return false}
    if lhs.yamlResult != rhs.yamlResult {return false}
    if lhs.logMessage != rhs.logMessage {return false}
    if lhs.errMessage != rhs.errMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_BuildProgram_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildProgram_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exec_args"),
    2: .same(proto: "output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._execArgs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.output) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._execArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.output.isEmpty {
      try visitor.visitSingularStringField(value: self.output, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_BuildProgram_Args, rhs: Com_Kcl_Api_BuildProgram_Args) -> Bool {
    if lhs._execArgs != rhs._execArgs {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_BuildProgram_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildProgram_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_BuildProgram_Result, rhs: Com_Kcl_Api_BuildProgram_Result) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ExecArtifact_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecArtifact_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "exec_args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execArgs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try { if let v = self._execArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ExecArtifact_Args, rhs: Com_Kcl_Api_ExecArtifact_Args) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._execArgs != rhs._execArgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_FormatCode_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FormatCode_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_FormatCode_Args, rhs: Com_Kcl_Api_FormatCode_Args) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_FormatCode_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FormatCode_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "formatted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.formatted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.formatted.isEmpty {
      try visitor.visitSingularBytesField(value: self.formatted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_FormatCode_Result, rhs: Com_Kcl_Api_FormatCode_Result) -> Bool {
    if lhs.formatted != rhs.formatted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_FormatPath_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FormatPath_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_FormatPath_Args, rhs: Com_Kcl_Api_FormatPath_Args) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_FormatPath_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FormatPath_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "changed_paths"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.changedPaths) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.changedPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.changedPaths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_FormatPath_Result, rhs: Com_Kcl_Api_FormatPath_Result) -> Bool {
    if lhs.changedPaths != rhs.changedPaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_LintPath_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LintPath_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paths"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_LintPath_Args, rhs: Com_Kcl_Api_LintPath_Args) -> Bool {
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_LintPath_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LintPath_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedStringField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_LintPath_Result, rhs: Com_Kcl_Api_LintPath_Result) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_OverrideFile_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OverrideFile_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    2: .same(proto: "specs"),
    3: .standard(proto: "import_paths"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.specs) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.importPaths) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 1)
    }
    if !self.specs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.specs, fieldNumber: 2)
    }
    if !self.importPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.importPaths, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_OverrideFile_Args, rhs: Com_Kcl_Api_OverrideFile_Args) -> Bool {
    if lhs.file != rhs.file {return false}
    if lhs.specs != rhs.specs {return false}
    if lhs.importPaths != rhs.importPaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_OverrideFile_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OverrideFile_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "parse_errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.parseErrors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    if !self.parseErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parseErrors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_OverrideFile_Result, rhs: Com_Kcl_Api_OverrideFile_Result) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.parseErrors != rhs.parseErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListVariables_Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListVariables_Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "merge_program"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.mergeProgram) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mergeProgram != false {
      try visitor.visitSingularBoolField(value: self.mergeProgram, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListVariables_Options, rhs: Com_Kcl_Api_ListVariables_Options) -> Bool {
    if lhs.mergeProgram != rhs.mergeProgram {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_VariableList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariableList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_VariableList, rhs: Com_Kcl_Api_VariableList) -> Bool {
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListVariables_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListVariables_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "specs"),
    3: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.specs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.specs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.specs, fieldNumber: 2)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListVariables_Args, rhs: Com_Kcl_Api_ListVariables_Args) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.specs != rhs.specs {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListVariables_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListVariables_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variables"),
    2: .standard(proto: "unsupported_codes"),
    3: .standard(proto: "parse_errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_VariableList>.self, value: &self.variables) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.unsupportedCodes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parseErrors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variables.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_VariableList>.self, value: self.variables, fieldNumber: 1)
    }
    if !self.unsupportedCodes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unsupportedCodes, fieldNumber: 2)
    }
    if !self.parseErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parseErrors, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListVariables_Result, rhs: Com_Kcl_Api_ListVariables_Result) -> Bool {
    if lhs.variables != rhs.variables {return false}
    if lhs.unsupportedCodes != rhs.unsupportedCodes {return false}
    if lhs.parseErrors != rhs.parseErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Variable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Variable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "type_name"),
    3: .standard(proto: "op_sym"),
    4: .standard(proto: "list_items"),
    5: .standard(proto: "dict_entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.typeName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.opSym) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.listItems) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.dictEntries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.typeName.isEmpty {
      try visitor.visitSingularStringField(value: self.typeName, fieldNumber: 2)
    }
    if !self.opSym.isEmpty {
      try visitor.visitSingularStringField(value: self.opSym, fieldNumber: 3)
    }
    if !self.listItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listItems, fieldNumber: 4)
    }
    if !self.dictEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dictEntries, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Variable, rhs: Com_Kcl_Api_Variable) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.typeName != rhs.typeName {return false}
    if lhs.opSym != rhs.opSym {return false}
    if lhs.listItems != rhs.listItems {return false}
    if lhs.dictEntries != rhs.dictEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_MapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MapEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_MapEntry, rhs: Com_Kcl_Api_MapEntry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_GetSchemaTypeMapping_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSchemaTypeMapping_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exec_args"),
    2: .standard(proto: "schema_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._execArgs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._execArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_GetSchemaTypeMapping_Args, rhs: Com_Kcl_Api_GetSchemaTypeMapping_Args) -> Bool {
    if lhs._execArgs != rhs._execArgs {return false}
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_GetSchemaTypeMapping_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSchemaTypeMapping_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "schema_type_mapping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_KclType>.self, value: &self.schemaTypeMapping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaTypeMapping.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_KclType>.self, value: self.schemaTypeMapping, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_GetSchemaTypeMapping_Result, rhs: Com_Kcl_Api_GetSchemaTypeMapping_Result) -> Bool {
    if lhs.schemaTypeMapping != rhs.schemaTypeMapping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_GetSchemaTypeMappingUnderPath_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSchemaTypeMappingUnderPath_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "schema_type_mapping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_SchemaTypes>.self, value: &self.schemaTypeMapping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaTypeMapping.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_SchemaTypes>.self, value: self.schemaTypeMapping, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_GetSchemaTypeMappingUnderPath_Result, rhs: Com_Kcl_Api_GetSchemaTypeMappingUnderPath_Result) -> Bool {
    if lhs.schemaTypeMapping != rhs.schemaTypeMapping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_SchemaTypes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SchemaTypes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "schema_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.schemaType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaType.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schemaType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_SchemaTypes, rhs: Com_Kcl_Api_SchemaTypes) -> Bool {
    if lhs.schemaType != rhs.schemaType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ValidateCode_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidateCode_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datafile"),
    2: .same(proto: "data"),
    3: .same(proto: "file"),
    4: .same(proto: "code"),
    5: .same(proto: "schema"),
    6: .standard(proto: "attribute_name"),
    7: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datafile) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.schema) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.attributeName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datafile.isEmpty {
      try visitor.visitSingularStringField(value: self.datafile, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 3)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 4)
    }
    if !self.schema.isEmpty {
      try visitor.visitSingularStringField(value: self.schema, fieldNumber: 5)
    }
    if !self.attributeName.isEmpty {
      try visitor.visitSingularStringField(value: self.attributeName, fieldNumber: 6)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ValidateCode_Args, rhs: Com_Kcl_Api_ValidateCode_Args) -> Bool {
    if lhs.datafile != rhs.datafile {return false}
    if lhs.data != rhs.data {return false}
    if lhs.file != rhs.file {return false}
    if lhs.code != rhs.code {return false}
    if lhs.schema != rhs.schema {return false}
    if lhs.attributeName != rhs.attributeName {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ValidateCode_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidateCode_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "err_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ValidateCode_Result, rhs: Com_Kcl_Api_ValidateCode_Result) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errMessage != rhs.errMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "line"),
    2: .same(proto: "column"),
    3: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.line) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.column) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.line != 0 {
      try visitor.visitSingularInt64Field(value: self.line, fieldNumber: 1)
    }
    if self.column != 0 {
      try visitor.visitSingularInt64Field(value: self.column, fieldNumber: 2)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Position, rhs: Com_Kcl_Api_Position) -> Bool {
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListDepFiles_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDepFiles_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "work_dir"),
    2: .standard(proto: "use_abs_path"),
    3: .standard(proto: "include_all"),
    4: .standard(proto: "use_fast_parser"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workDir) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.useAbsPath) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeAll) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.useFastParser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workDir.isEmpty {
      try visitor.visitSingularStringField(value: self.workDir, fieldNumber: 1)
    }
    if self.useAbsPath != false {
      try visitor.visitSingularBoolField(value: self.useAbsPath, fieldNumber: 2)
    }
    if self.includeAll != false {
      try visitor.visitSingularBoolField(value: self.includeAll, fieldNumber: 3)
    }
    if self.useFastParser != false {
      try visitor.visitSingularBoolField(value: self.useFastParser, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListDepFiles_Args, rhs: Com_Kcl_Api_ListDepFiles_Args) -> Bool {
    if lhs.workDir != rhs.workDir {return false}
    if lhs.useAbsPath != rhs.useAbsPath {return false}
    if lhs.includeAll != rhs.includeAll {return false}
    if lhs.useFastParser != rhs.useFastParser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_ListDepFiles_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDepFiles_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkgroot"),
    2: .same(proto: "pkgpath"),
    3: .same(proto: "files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pkgroot) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pkgpath) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pkgroot.isEmpty {
      try visitor.visitSingularStringField(value: self.pkgroot, fieldNumber: 1)
    }
    if !self.pkgpath.isEmpty {
      try visitor.visitSingularStringField(value: self.pkgpath, fieldNumber: 2)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_ListDepFiles_Result, rhs: Com_Kcl_Api_ListDepFiles_Result) -> Bool {
    if lhs.pkgroot != rhs.pkgroot {return false}
    if lhs.pkgpath != rhs.pkgpath {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_LoadSettingsFiles_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadSettingsFiles_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "work_dir"),
    2: .same(proto: "files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workDir) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workDir.isEmpty {
      try visitor.visitSingularStringField(value: self.workDir, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_LoadSettingsFiles_Args, rhs: Com_Kcl_Api_LoadSettingsFiles_Args) -> Bool {
    if lhs.workDir != rhs.workDir {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_LoadSettingsFiles_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadSettingsFiles_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kcl_cli_configs"),
    2: .standard(proto: "kcl_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._kclCliConfigs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.kclOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._kclCliConfigs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.kclOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kclOptions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_LoadSettingsFiles_Result, rhs: Com_Kcl_Api_LoadSettingsFiles_Result) -> Bool {
    if lhs._kclCliConfigs != rhs._kclCliConfigs {return false}
    if lhs.kclOptions != rhs.kclOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_CliConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CliConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "output"),
    3: .same(proto: "overrides"),
    4: .standard(proto: "path_selector"),
    5: .standard(proto: "strict_range_check"),
    6: .standard(proto: "disable_none"),
    7: .same(proto: "verbose"),
    8: .same(proto: "debug"),
    9: .standard(proto: "sort_keys"),
    10: .standard(proto: "show_hidden"),
    11: .standard(proto: "include_schema_type_path"),
    12: .standard(proto: "fast_eval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.output) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.overrides) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.pathSelector) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.strictRangeCheck) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disableNone) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.verbose) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.debug) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.sortKeys) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.showHidden) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.includeSchemaTypePath) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.fastEval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularStringField(value: self.output, fieldNumber: 2)
    }
    if !self.overrides.isEmpty {
      try visitor.visitRepeatedStringField(value: self.overrides, fieldNumber: 3)
    }
    if !self.pathSelector.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pathSelector, fieldNumber: 4)
    }
    if self.strictRangeCheck != false {
      try visitor.visitSingularBoolField(value: self.strictRangeCheck, fieldNumber: 5)
    }
    if self.disableNone != false {
      try visitor.visitSingularBoolField(value: self.disableNone, fieldNumber: 6)
    }
    if self.verbose != 0 {
      try visitor.visitSingularInt64Field(value: self.verbose, fieldNumber: 7)
    }
    if self.debug != false {
      try visitor.visitSingularBoolField(value: self.debug, fieldNumber: 8)
    }
    if self.sortKeys != false {
      try visitor.visitSingularBoolField(value: self.sortKeys, fieldNumber: 9)
    }
    if self.showHidden != false {
      try visitor.visitSingularBoolField(value: self.showHidden, fieldNumber: 10)
    }
    if self.includeSchemaTypePath != false {
      try visitor.visitSingularBoolField(value: self.includeSchemaTypePath, fieldNumber: 11)
    }
    if self.fastEval != false {
      try visitor.visitSingularBoolField(value: self.fastEval, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_CliConfig, rhs: Com_Kcl_Api_CliConfig) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.output != rhs.output {return false}
    if lhs.overrides != rhs.overrides {return false}
    if lhs.pathSelector != rhs.pathSelector {return false}
    if lhs.strictRangeCheck != rhs.strictRangeCheck {return false}
    if lhs.disableNone != rhs.disableNone {return false}
    if lhs.verbose != rhs.verbose {return false}
    if lhs.debug != rhs.debug {return false}
    if lhs.sortKeys != rhs.sortKeys {return false}
    if lhs.showHidden != rhs.showHidden {return false}
    if lhs.includeSchemaTypePath != rhs.includeSchemaTypePath {return false}
    if lhs.fastEval != rhs.fastEval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_KeyValuePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyValuePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_KeyValuePair, rhs: Com_Kcl_Api_KeyValuePair) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Rename_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rename_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_root"),
    2: .standard(proto: "symbol_path"),
    3: .standard(proto: "file_paths"),
    4: .standard(proto: "new_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.packageRoot) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbolPath) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.filePaths) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.newName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packageRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.packageRoot, fieldNumber: 1)
    }
    if !self.symbolPath.isEmpty {
      try visitor.visitSingularStringField(value: self.symbolPath, fieldNumber: 2)
    }
    if !self.filePaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filePaths, fieldNumber: 3)
    }
    if !self.newName.isEmpty {
      try visitor.visitSingularStringField(value: self.newName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Rename_Args, rhs: Com_Kcl_Api_Rename_Args) -> Bool {
    if lhs.packageRoot != rhs.packageRoot {return false}
    if lhs.symbolPath != rhs.symbolPath {return false}
    if lhs.filePaths != rhs.filePaths {return false}
    if lhs.newName != rhs.newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Rename_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rename_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "changed_files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.changedFiles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.changedFiles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.changedFiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Rename_Result, rhs: Com_Kcl_Api_Rename_Result) -> Bool {
    if lhs.changedFiles != rhs.changedFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_RenameCode_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameCode_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_root"),
    2: .standard(proto: "symbol_path"),
    3: .standard(proto: "source_codes"),
    4: .standard(proto: "new_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.packageRoot) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.symbolPath) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.sourceCodes) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.newName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packageRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.packageRoot, fieldNumber: 1)
    }
    if !self.symbolPath.isEmpty {
      try visitor.visitSingularStringField(value: self.symbolPath, fieldNumber: 2)
    }
    if !self.sourceCodes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.sourceCodes, fieldNumber: 3)
    }
    if !self.newName.isEmpty {
      try visitor.visitSingularStringField(value: self.newName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_RenameCode_Args, rhs: Com_Kcl_Api_RenameCode_Args) -> Bool {
    if lhs.packageRoot != rhs.packageRoot {return false}
    if lhs.symbolPath != rhs.symbolPath {return false}
    if lhs.sourceCodes != rhs.sourceCodes {return false}
    if lhs.newName != rhs.newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_RenameCode_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameCode_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "changed_codes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.changedCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.changedCodes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.changedCodes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_RenameCode_Result, rhs: Com_Kcl_Api_RenameCode_Result) -> Bool {
    if lhs.changedCodes != rhs.changedCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Test_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Test_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exec_args"),
    2: .standard(proto: "pkg_list"),
    3: .standard(proto: "run_regexp"),
    4: .standard(proto: "fail_fast"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._execArgs) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pkgList) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runRegexp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.failFast) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._execArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pkgList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pkgList, fieldNumber: 2)
    }
    if !self.runRegexp.isEmpty {
      try visitor.visitSingularStringField(value: self.runRegexp, fieldNumber: 3)
    }
    if self.failFast != false {
      try visitor.visitSingularBoolField(value: self.failFast, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Test_Args, rhs: Com_Kcl_Api_Test_Args) -> Bool {
    if lhs._execArgs != rhs._execArgs {return false}
    if lhs.pkgList != rhs.pkgList {return false}
    if lhs.runRegexp != rhs.runRegexp {return false}
    if lhs.failFast != rhs.failFast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Test_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Test_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.info.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.info, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Test_Result, rhs: Com_Kcl_Api_Test_Result) -> Bool {
    if lhs.info != rhs.info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_TestCaseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestCaseInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "error"),
    3: .same(proto: "duration"),
    4: .standard(proto: "log_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.logMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularUInt64Field(value: self.duration, fieldNumber: 3)
    }
    if !self.logMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.logMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_TestCaseInfo, rhs: Com_Kcl_Api_TestCaseInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.error != rhs.error {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.logMessage != rhs.logMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_UpdateDependencies_Args: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDependencies_Args"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "manifest_path"),
    2: .same(proto: "vendor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.manifestPath) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.vendor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.manifestPath.isEmpty {
      try visitor.visitSingularStringField(value: self.manifestPath, fieldNumber: 1)
    }
    if self.vendor != false {
      try visitor.visitSingularBoolField(value: self.vendor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_UpdateDependencies_Args, rhs: Com_Kcl_Api_UpdateDependencies_Args) -> Bool {
    if lhs.manifestPath != rhs.manifestPath {return false}
    if lhs.vendor != rhs.vendor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_UpdateDependencies_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDependencies_Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "external_pkgs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.externalPkgs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalPkgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.externalPkgs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_UpdateDependencies_Result, rhs: Com_Kcl_Api_UpdateDependencies_Result) -> Bool {
    if lhs.externalPkgs != rhs.externalPkgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_KclType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KclType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "union_types"),
    3: .same(proto: "default"),
    4: .standard(proto: "schema_name"),
    5: .standard(proto: "schema_doc"),
    6: .same(proto: "properties"),
    7: .same(proto: "required"),
    8: .same(proto: "key"),
    9: .same(proto: "item"),
    10: .same(proto: "line"),
    11: .same(proto: "decorators"),
    12: .same(proto: "filename"),
    13: .standard(proto: "pkg_path"),
    14: .same(proto: "description"),
    15: .same(proto: "examples"),
    16: .standard(proto: "base_schema"),
  ]

  fileprivate class _StorageClass {
    var _type: String = String()
    var _unionTypes: [Com_Kcl_Api_KclType] = []
    var _default: String = String()
    var _schemaName: String = String()
    var _schemaDoc: String = String()
    var _properties: Dictionary<String,Com_Kcl_Api_KclType> = [:]
    var _required: [String] = []
    var _key: Com_Kcl_Api_KclType? = nil
    var _item: Com_Kcl_Api_KclType? = nil
    var _line: Int32 = 0
    var _decorators: [Com_Kcl_Api_Decorator] = []
    var _filename: String = String()
    var _pkgPath: String = String()
    var _description_p: String = String()
    var _examples: Dictionary<String,Com_Kcl_Api_Example> = [:]
    var _baseSchema: Com_Kcl_Api_KclType? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _unionTypes = source._unionTypes
      _default = source._default
      _schemaName = source._schemaName
      _schemaDoc = source._schemaDoc
      _properties = source._properties
      _required = source._required
      _key = source._key
      _item = source._item
      _line = source._line
      _decorators = source._decorators
      _filename = source._filename
      _pkgPath = source._pkgPath
      _description_p = source._description_p
      _examples = source._examples
      _baseSchema = source._baseSchema
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._unionTypes) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._default) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._schemaName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._schemaDoc) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_KclType>.self, value: &_storage._properties) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._required) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._item) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._line) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._decorators) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._filename) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._pkgPath) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_Example>.self, value: &_storage._examples) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._baseSchema) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._unionTypes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._unionTypes, fieldNumber: 2)
      }
      if !_storage._default.isEmpty {
        try visitor.visitSingularStringField(value: _storage._default, fieldNumber: 3)
      }
      if !_storage._schemaName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._schemaName, fieldNumber: 4)
      }
      if !_storage._schemaDoc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._schemaDoc, fieldNumber: 5)
      }
      if !_storage._properties.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_KclType>.self, value: _storage._properties, fieldNumber: 6)
      }
      if !_storage._required.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._required, fieldNumber: 7)
      }
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._line != 0 {
        try visitor.visitSingularInt32Field(value: _storage._line, fieldNumber: 10)
      }
      if !_storage._decorators.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._decorators, fieldNumber: 11)
      }
      if !_storage._filename.isEmpty {
        try visitor.visitSingularStringField(value: _storage._filename, fieldNumber: 12)
      }
      if !_storage._pkgPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pkgPath, fieldNumber: 13)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 14)
      }
      if !_storage._examples.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Com_Kcl_Api_Example>.self, value: _storage._examples, fieldNumber: 15)
      }
      try { if let v = _storage._baseSchema {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_KclType, rhs: Com_Kcl_Api_KclType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._unionTypes != rhs_storage._unionTypes {return false}
        if _storage._default != rhs_storage._default {return false}
        if _storage._schemaName != rhs_storage._schemaName {return false}
        if _storage._schemaDoc != rhs_storage._schemaDoc {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._required != rhs_storage._required {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._line != rhs_storage._line {return false}
        if _storage._decorators != rhs_storage._decorators {return false}
        if _storage._filename != rhs_storage._filename {return false}
        if _storage._pkgPath != rhs_storage._pkgPath {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._examples != rhs_storage._examples {return false}
        if _storage._baseSchema != rhs_storage._baseSchema {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Decorator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Decorator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "arguments"),
    3: .same(proto: "keywords"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.keywords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 2)
    }
    if !self.keywords.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.keywords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Decorator, rhs: Com_Kcl_Api_Decorator) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.keywords != rhs.keywords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Kcl_Api_Example: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Example"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "summary"),
    2: .same(proto: "description"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Kcl_Api_Example, rhs: Com_Kcl_Api_Example) -> Bool {
    if lhs.summary != rhs.summary {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
